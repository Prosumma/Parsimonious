//
//  ParsimoniousTests.swift
//  ParsimoniousTests
//
//  Created by Gregory Higley on 2/28/19.
//  Copyright Â© 2019 Prosumma LLC. All rights reserved.
//

import XCTest
@testable import Parsimonious

indirect enum JSON {
    case string(String)
    case number(NSNumber)
    case boolean(Bool)
    case object([String: JSON])
    case array([JSON])
}

let escape: Character = "\\"
let quote: Character = "\""

let quotation = char(quote) *> manyS(char(all: !escape, !quote) | (char(escape) *> char(any: escape, quote))) <* char(quote)
let jstring = JSON.string <*> quotation

func jnumber(_ context: Context<String>) throws -> JSON {
    let digits = many1S("0123456789")
    let dot: Character = "."
    let num = digits + optionalS(char(dot) + digits)
    let formatter = NumberFormatter()
    formatter.numberStyle = .decimal
    let ns = try context <- num
    guard let n = formatter.number(from: ns) else {
        throw ParseError(message: "Expected a number, but got \(ns).", context: context)
    }
    return JSON.number(n)
}

func jboolError(_ s: Substring?) -> String {
    guard let s = s else {
        return "Expected to match 'true' or 'false' but got EOF."
    }
    return "Expected to match 'true' or 'false', but got '\(s[upTo: 5])'."
}
let jbool = {s in JSON.boolean(s == "true")} <*> string("true") | string("false") | fail(jboolError)

let ws = manyS(\Character.isWhitespace)

func jarray(_ context: Context<String>) throws -> JSON {
    return try context <- JSON.array <*> char("[") *> ws *> many(json <* ws, sepBy: ws + char(",") + ws) <* char("]")
}

func jpair(_ context: Context<String>) throws -> (key: String, value: JSON) {
    return try context.transact {
        let key = try context <- quotation
        try context <- ws + char(":") + ws
        let value = try context <- json
        return (key, value)
    }
}

func jobject(_ context: Context<String>) throws -> JSON {
    return try context.transact {
        try context <- char("{") <* ws
        let pairs = try context <- many(jpair <* ws, sepBy: ws + char(",") + ws)
        try context <- char("}")
        var object: [String: JSON] = [:]
        for pair in pairs {
            object[pair.key] = pair.value
        }
        return JSON.object(object)
    }
}

let json = jstring | jnumber | jbool | jarray | jobject

class ParsimoniousTests: XCTestCase {
    
    static var rawData: Data = Data()
    static var rawJSON: String = "--NOTJSON--"
    
    override class func setUp() {
        super.setUp()
        let bundle = Bundle(for: ParsimoniousTests.self)
        // Random JSON generated by https://next.json-generator.com.
        let path = bundle.path(forResource: "Random", ofType: "json")!
        rawData = try! Data(contentsOf: URL(fileURLWithPath: path))
        rawJSON = String(data: rawData, encoding: .utf8)!
    }

    func testParser() {
        try XCTAssertNoThrow(parse(ParsimoniousTests.rawJSON, with: ws *> json <* ws))
    }
    
    func testParserPerformance() {
        measure {
            // About 200 times slower than `JSONSerialization`!
            // LESSON: Don't parse JSON with parser combinators if you care about speed!
            _ = try! parse(ParsimoniousTests.rawJSON, with: ws *> json <* ws)
        }
    }
        
}

